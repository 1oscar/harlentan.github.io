---
layout: post
title: C++如何禁止全局对象被析构
tags: [C/C++]
keywords: 全局对象析构, 禁止全局对象被析构, 如何禁止全局对象被析构, C++全局对象
description: C++如何禁止全局对象被析构
comments: true
share: true
---
&emsp;&emsp;全局对象无论是在C++中，还是在C(C里面的全局变量)里面 ，都是比较难管理而且不提倡过多的使用。一方面它生命周期不好控制 ，另一方面多线程中共享需要额外的消耗。另外，全局变量或者对象的初始化顺序不固定，在进程结束的时候全局对象的析构函数会被隐式调用，调用顺序也不固定。如果全局对象之间还有引用关系，会使得程序变得更加糟糕。这里主要讲一些技巧如何防止全局对象被析构。

<!--more-->

##前言   
&emsp;&emsp;一般情况下，我们都要求所有new出来的对象，在程序结束的时候，都要将其析构掉。但是在某些情况下，我们希望一些很重要的全局对象在程序运行的整个过程中都存在，而且生命周期跟进程相同。在这种情况下，其实是要防止全局对象被析构，即便是进程结束也不要调用其析构函数。例如：WebKit中JavaScriptCore的VM对象。WebKit的bindings里面，VM对象就是一个跟进程生命周期相同的一个全局变量。任何时候都不允许它被析构掉，如果被析构掉，HTML就无法执行JavaScript了。

##全局指针  
&emsp;&emsp;如果说到全局对象 ，可能大部分人第一时间想到的就是new一个对象，将其指针保存在全局变量里面。这种做法其实比较危险。new出来的指针放在全局变量里面，代码的其他任何地方都可以获取该指针，如果不小心被其他地方delete掉了呢？

##全局对象
&emsp;&emsp;采用直接保存全局对象的方案，可以避免上面提到的被其他地方delete掉。但是有一个缺点，进程结束的时候，该对象会隐式的被调用，也就是还有可能被析构掉。对于某些比较重要的对象，我们希望任何时候都不被析构掉，例如前面说的VM对象。

##静态局部变量
先来看一段代码：
{% highlight C++ linenos %}
class A {
public:
    A() {};
private:
    A(const A&);
    A(A&);
};

A& getInstance()
{
    static A* a = new A();
    A& obj = *a;
    return obj;
}
{% endhighlight %}
这段代码弥补了上面提到的全局指针和静态全局变量的缺点。避免了指针的直接传递，保证了全局对象的单实例。由于将拷贝构造函数声明为private，使得所有需要使用A对象的地方，都需要声明为引用，这样，即便是进程结束，其构造函数也不会被调用。
